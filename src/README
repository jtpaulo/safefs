Fuse Implementation working with libosxfuse

sfuse.c:

Fuse wrapper with security primitives when reading/writing data.
sfuse_main() receives the same arguments as fuse_main() and points fuse operations to the original ones, while reimplementing the operations that
must be secure (in this example, read and write).
In fuse_main it is also possible to assing the encode() and decode() operations to be used

fssecurity.h
Header file declaring the encode() and decode() operations.

nopcrypt.c 
Implementation of a encode() and decode() operation that basically just copies data without protecting it
A new security implementaton can be divised by writing a .c file that also implements the encode() and decode() functions.

sloopback.c
The original loopback driver provided in libosxfuse.
The only changes did to this code was to include "sfuse.c" instead of "fuse.h"
Also the main function call sfuse_main() instead of fuse_main()

This can be improved in the future to be even more transparent but for now it may be enough for the paper


/*
 * IMPORTANT
 
 * This version is for libosxfuse and not for the regular linux fuse
 * porting this to linux fuse should be really easy as the only think that should chnage are the includes (the functions should be the same)
 
 * TODO:
 * 	We want to chypher blocks and not the whole file since reading/writing a few bytes would
 * 	require reading the whole file content to encode/decode it
 *
 	 Blocks read and written may have different sizes (This is visible in FUSE calls)
 	 (e.g., we may want to read/modify only the first bytes of one block.

 	 Most cryptographic techniques requiring reading the whole block to decode it and require the whole block
 	 to cypher it.

 	 This way we need to choose a fixed block size (4KB, 16KB, 32 KB, 64KB?).
 	 If we do this, we must be sure to:

 	 - When intercepting writes we must read the full blocks and cypher them
 	 (if blocks are not aligned we may need to read more than one...)

 	 - When intercepting reads we must read the full block/blocks and then return only the
 	 bytes (portion of the block/blocks) that were requested
 	 
 	 
 	 A study for finding the best block size would be important.
 	 
 	 Also to check if there are cyphers that allow retrieving or recyphering only a portion of the previous cyphered data would be really helpfull to avoid this
 	 issue and the performance penalty of re-reading blocks.
 	 
 *
 *
 *
 */



			